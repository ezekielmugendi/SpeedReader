#' A function that generates plots similar to those in Monroe et al.
#' 'Fightin Words...'.
#'
#' @param feature_selection_object A list object generated by the
#' feature_selection function.
#' @param title A user supplied title for the plot.
#' @param positive_category The name the user wishes to give to the first
#' category specified when using the feature_selection function.
#' @param negative_category The name the user wishes to give to the second
#' category specified when using the feature_selection function.
#' @param xlab Defaults to 'Term Frequency', but can be modified as necessary.
#' @param display_top_words Defaults to 20 and controls the number of top terms
#' for each category displayed in the plot.
#' @param display_terms_next_to_points Optional argument, defaults to FALSE. If
#' TRUE, then terms are displayed next to the points corresponding to them on
#' the plot. Can get messy.
#' @param size_terms_by_frequency Optional argument, defualts to FALSE. If TRUE,
#' then when top terms are printed, they are sized in proportion to their
#' frequency.
#' @param right_margin Parameter controling how much space should be reserved
#' for the right margin in the plot (for displaying top terms). Defaults to 20
#' but can be adjusted depending on the length of terms.
#' @param max_terms_to_display Defaults to 100,000. Used to prevent overloading 
#' the plotting device with very large vocabularies. Can be set by the user.
#' @return A Fightin' Words plot
#' @export
fightin_words_plot <- function(feature_selection_object,
                               title,
                               positive_category,
                               negative_category,
                               xlab = "Term Frequency",
                               display_top_words = 20,
                               display_terms_next_to_points = FALSE,
                               size_terms_by_frequency = FALSE,
                               right_margin = 20,
                               max_terms_to_display = 100000) {
  options(scipen = 999)
  par(mar = c(5.1, 4.1, 4.1, right_margin))
  UMASS_BLUE <- rgb(51, 51, 153, 255, maxColorValue = 255)
  UMASS_RED <- rgb(153, 0, 51, 255, maxColorValue = 255)

  if (class(feature_selection_object) == "list") {
    zeta <- feature_selection_object[[3]]$scores
    y.tot <- feature_selection_object[[3]]$total_count
    words <- feature_selection_object[[3]]$terms
  } else if (class(feature_selection_object) == "data.frame") {
    zeta <- feature_selection_object$scores
    y.tot <- feature_selection_object$total_count
    words <- feature_selection_object$terms
  } else {
    stop("You must provide an object generate by the feature_selection function...")
  }
  
  if (length(zeta) > max_terms_to_display) {
    tot <- length(zeta)
    bound <- floor(max_terms_to_display/2)
    zeta <- c(zeta[1:bound], zeta[(tot-bound+1):tot]) 
    y.tot <- c(y.tot[1:bound], y.tot[(tot-bound+1):tot]) 
    words <- c(words[1:bound], words[(tot-bound+1):tot]) 
  }

  max_y.tot <- max(y.tot)

  max.zeta.one <- 1:display_top_words
  max.zeta.two <- length(zeta):(length(zeta) - display_top_words +
    1)

  display_limits <- 1.2 * max(abs(zeta))
  sig.z <- abs(zeta) > 1.96
  psize <- 2 * abs(zeta)/max(abs(zeta))
  plot(c(1, 2 * max_y.tot), c(-display_limits, display_limits),
    type = "n", log = "x", pch = 19, col = "black", cex = psize,
    main = title, ylab = paste(negative_category, " vs. ",
      positive_category, sep = ""), xlab = xlab)
  points(y.tot, zeta, pch = 19, col = "gray", cex = psize)
  points(y.tot[sig.z], zeta[sig.z], pch = 19, col = "black",
    cex = psize[sig.z])
  points(y.tot[max.zeta.one], zeta[max.zeta.one], pch = 19,
    col = UMASS_BLUE, cex = psize[max.zeta.one])
  points(y.tot[max.zeta.two], zeta[max.zeta.two], pch = 19,
    col = UMASS_RED, cex = psize[max.zeta.two])

  if (size_terms_by_frequency) {
      mtext(text = words[max.zeta.one], side = 4, col = UMASS_BLUE,
            las = 1, line = 1, at = seq(0.95 * display_limits,
            0.05 * display_limits, length.out = display_top_words),
            cex = psize[max.zeta.one])
      mtext(text = words[max.zeta.two], side = 4, col = UMASS_RED,
            las = 1, line = 1, at = seq(-0.95 * display_limits,
            -0.05 * display_limits, length.out = display_top_words),
            cex = psize[max.zeta.two])
  } else {
    mtext(text = words[max.zeta.one], side = 4, col = UMASS_BLUE,
      las = 1, line = 1, at = seq(0.95 * display_limits,
        0.05 * display_limits, length.out = display_top_words))
    mtext(text = words[max.zeta.two], side = 4, col = UMASS_RED,
      las = 1, line = 1, at = seq(-0.95 * display_limits,
        -0.05 * display_limits, length.out = display_top_words))
  }


  if (display_terms_next_to_points) {
    text(y.tot[max.zeta.one], zeta[max.zeta.one], words[max.zeta.one],
      pch = 19, col = UMASS_BLUE, pos = 4, cex = psize[max.zeta.one])
    text(y.tot[max.zeta.two], zeta[max.zeta.two], words[max.zeta.two],
      pch = 19, col = UMASS_RED, pos = 4, cex = psize[max.zeta.two])
  }

  text(1, 0.9 * display_limits, positive_category, col = UMASS_BLUE,
    pos = 4, cex = 2)
  text(1, -0.9 * display_limits, negative_category, col = UMASS_RED,
    pos = 4, cex = 2)

}
